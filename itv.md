<div align='center' ><font size='70'>Itv</font></div>

# 目录

# 基础知识

## 字节序

# 操作系统

## CPU寻址方式
  * 实模式：程序访问的地址都是真实的物理地址，如8086中“段基址：段内偏移地址”产生的逻辑地址就是物理地址。缺点：用户程序和操作系统拥有同等权利，程序可以随意修改任意物理地址，甚至包括操作系统所在的内存，给操作系统带来极大的安全问题
  * 保护模式：CPU访问的所有地址都是逻辑地址（段寄存器都为0的话，逻辑地址就是虚拟地址），CPU会通过“分段”或者“分页”方式来查寻到对应的物理地址。优点：不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持，支持多任务，能够快速地进行任务切换和保护任务环境

## <a id="vms">虚拟地址空间</a>[^更多关于虚拟地址空间的内容]
  ![image](img/mem_space_cmp.jpg)
  以32位机器举例，进程的虚拟地址空间最大为4GB，其中1GB为内核空间（所有进程共享），进程可访问的实际用户空间只有3GB。
  Linux进程的内存段组成如下：
  * 保留区：0x00000000-0x08048000
  * 代码段（text）：线程间共享，只读
  * 数据段（data）：存放已初始化的且初始值不为0的全局变量和静态局部变量，可读写
  * BSS段：存放未初始化的静态变量、初始值为0的初始化的全局变量和静态变量、未定义且初值不为0的符号（该初值即common block的大小）。BSS段不占用可执行文件空间，推迟到加载阶段初始化为0（符号表中会有相关变量的描述）
  * 堆（heap）：堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减
  * 内存映射段（mmap）：mmap将文件映射到该段
  * 栈（stack）：由编译器自动分配释放，用于存放函数内的非静态局部变量、栈帧，可动态增长至RLIMIT_STACK
  * 环境变量和命令行参数
  * 其他
    * 只读数据段（rodata）：进程间共享，编译器自动去重。常量不一定在rodata，有可能在text
    * common段：存放未初始化的全局变量（有的编译器会直接放在BSS段）
      > 强符号和弱符号
      > * 强符号指函数和初始化的全局变量（包括初始值为0的），弱符号指未初始化的全局变量
      > * 同名的强符号只能有一个，否则链接器报"重复定义"错误
      > * 如果一个符号在某个目标文件中是强符号，在其他文件中是弱符号，那么选择强符号
      > * 如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个
      > * 应用：程序在未正常链接某个库时也可以正常运行、库中定义的弱符号可以被用户定义的强符号所覆盖（例如版本用户自定义）
      > 
      > 举例：
      > ```C
      > int a;                           # 弱符号
      > int b = 0;                       # 强符号
      > extern int c;                    # 外部符号，只是一个符号引用，即不是强符号也不是弱符号
      > int __attribute__((weak)) d = 2; # 弱符号
      > 
      > #if defined(_WIN32)
      >   #pragma weak e
      >   int e = 2;                     # 弱符号
      > #endif
      > 
      > int
      > main ()
      > {
      >   return 0;
      > }
      > ```

  ![image](img/Linux_mem_X86.jpg)
  ![image](img/Linux_mem_X64.jpg)
  
  目标文件各个段在文件中的布局：
  ![image](img/elf_and_proc.png)

  > [更多内容](https://fanlv.wiki/2021/07/25/linux-mem/)
  
## mmap和shm
  * mmap（内存映射）：
    * 将一个文件或者其它对象映射到进程的虚拟地址空间，使用户对这段内存区域的修改可以直接反映到内核空间，相反，内核空间对这段区域的修改也直接反映用户空间
    * 读写文件时不再需要使用read、write等系统调用对文件进行读写，减少一次拷贝
    * 当访问该区域的内存页时，若该地址的数据不在内存，则产生缺页中断，OS会从磁盘中拷贝对应页到物理内存
    * 对该区域的内存页写入后，会自动延迟回写脏页面到对应磁盘地址，也可使用msync()即时写入
    * mmap 不仅可以映射到磁盘上的普通文件，还可以映射到匿名文件，但匿名映射只能在父子进程中使用
  * shm（共享内存）：
    * 将新开辟的物理内存映射到不同进程的虚拟地址空间
  * malloc分配大内存实际调用的是mmap
  * 区别：
    * mmap和shm都可以达到进程间通信和进共享的目的，但shm性能更高
    * mmap实际存储反应到硬盘，shm实际存储反应到内存
    * 对于普通文件的mmap映射，当机器重启，mmap文件还保存了同步映像

## 栈、堆
  * 栈：
    * [进程栈](#vms)
    * 线程栈
    * 内核栈
    * 中断栈
    > Linux的栈大小默认为8M（ulimit -s），可使用 `ulimit -s` 修改，Windows的栈大小默认为1M（VC6），可使用 `/stack` 参数修改
  * 堆：
    *
  * 栈和堆的区别：
    * 生长方向：栈的地址增长方向取决于平台和编译器实现（比如x86的栈是向下增长的，原因是栈向下增长，堆向上增长，可以提高内存利用率）
    * 分配方式：栈由编译器自动分配和释放。堆由程序员控制，容易产生内存泄露
    * 空间大小：栈顶地址和栈的最大容量由系统预先规定，栈的大小超容量限制会栈溢出。堆的大小则受限于计算机系统中有效的地址空间
    * 效率：压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率较低
    * 碎片问题：栈是先进后出的队列，不存在碎片问题。堆的频繁申请释放操作会造成内存空间不连续，从而造成大量碎片，使程序效率降低

## 存储区域
  * 静态存储区：BSS段、数据段、代码段
  * 动态存储区：堆、栈

## 动态库、静态库

### 动态库
  * dlopen
### 静态库
  *
### **注意**
  1. **动态库中的全局变量、静态变量在进程间不会相互覆盖，写时拷贝（进程修改动态库中的全局变量、静态变量时，操作系统会重新分配内存并映射到进程地址空间，变量的逻辑地址不变）**
  2. **可执行文件和动态库同时引用同一个静态库，静态库中的全局变量和静态变量会分别初始化一次**

# 编译原理

## fPIC和fPIE
  * PIC（位置无关代码）
  * PIE（位置无关可执行程序）
  
## _stdcall和__stdcall、_fastcall的区别
  * __cdecl是C/C++和MFC程序默认使用的调用约定。函数参数按照从右到左的顺序入栈，并且由调用函数者把参数弹出栈以清理堆栈（可变参数只能用__cdecll；由于每个调用__cdecl函数的代码都要包含清理堆栈的代码，产生的可执行文件大小会比较大）
  * __stdcall调用约定用于调用Win32 API函数。函数参数按照从右到左的顺序入栈，被调用的函数在返回前清理传送参数的栈，函数参数个数固定
  * __fastcall约定用于对性能要求非常高的场合。_fastcall约定将函数的从左边开始的两个大小不大于4个字节（DWORD）的参数分别放在ECX和EDX寄存器，其余的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的堆栈。（__fastcall可以写成_fastcall）
  * thiscall仅仅应用于"C++"成员函数。this指针存放于CX寄存器，函数参数按照从右到左的顺序入栈，不能被程序员指定
  

# 汇编

## ESP、EBP
  * ESP（栈指针寄存器/栈指针）：永远指向系统栈栈顶
  * EBP（基址指针寄存器/帧指针）：永远指向系统栈栈底
  ![image](img/stack_frame.png)

# UNPV
  * [UNPV](https://github.com/ManyyWu/Notes/blob/master/Linux/Programming/UNP%E7%AC%94%E8%AE%B0.md)
  * [服务器IO模型](https://fanlv.wiki/2018/07/15/server-io-model/)

# [Shell](https://github.com/ManyyWu/Notes/blob/master/Linux/Programming/Shell.md)

# [MySQl](https://fanlv.wiki/categories/MySQL/)

# [Redis](https://fanlv.wiki/categories/Redis/)