# 目录


# C/C++

## 字节序

## 指针和引用
  * 指针即引用内容的地址，是一个实体
  * 引用是别名，对引用取地址即取引用内容的地址
  * 不存在空引用，引用定义时必须初始化，并且初始化后不能改变
  * 引用的sizeof是引用变量的大小，而指针的sizeof是指针变量的大小
  * 引用自增是引用变量自增，指针自增使指针指向下一个元素（数组名不能自增）

## const \*和\* const区别
  * const默认修饰左边的对象，若左边没有对象，则修饰右边的对象
  ```C++
  const int *p;             // 修饰int
  int const *p;             // 修饰int
  int * const p = pp;       // 修饰int *
  const int * const p = pp; // 修饰int和int *
  ```

## 左值和右值
  * 左值是可寻址的变量（字符串常量、前置自增/自减的表达式是左值）
  * 右值一般是不可寻址的常量或在表达式求值过程中创建的无名临时对象
    * 纯右值（C++11之前的右值）：字面值、非引用的返回值、后置自增/自减的表达式、运算结果是字面值或临时对象的表达式、lambda表达式
    * 将亡值（C++11新增）：可使用右值引用延长生命周期（续命）
  * 左值引用：
  
    ```C++
    int a = 1;
    int &ra = a;
    const int &a1 = 1; // 常引用
    ```
  * 右值引用：
  
    ```C++
    int a = 1;
    int &&rr1 = 1;
    int &&rra = std::move(a);
    // 右值引用本身是左值
    ```
  * 引用折叠与完美转发：

    ```C++
    // T& &、T& &&、T&& &都折叠为T&
    // T&& &&折叠为T&&
    template <typename T>
    void
    f(T* p) {
      std::cout << "p" << " ";
    }

    template <typename T>
    void
    f(T& r) {
      std::cout << "r" << " ";
    }

    template <typename T>
    void
    f(T&& rr) {
      std::cout << "rr" << " ";
    }

    template <typename T>
    void
    ff(T&& rr) {
      // rr为左值
      f(rr);                  // T & &&  => void f(int T &)
      f(std::forward<T>(rr)); // 完美转发
      std::cout << std::endl;
    }

    int
    main(void) {
      int a = 1;
      int &ra = a;
      int *pa = &a;
      const int& r1 = 1;

      ff(std::move(a)); // T && &&       => void f(int &&)
      ff(1);            // T &&          => void f(int &&)
      ff(ra);           // T & &&        => void f(int &)
      ff(pa);           // T * &&        => void f(int *)，如果void f(T *p)未定义则实例化为void f(int *&)
      ff(r1);           // const T & &&  => void f(const int &)

      return 0;
    }
    
    //输出结果：
    //r rr
    //r rr
    //r r
    //p p
    //r r
    ```
  * std::move：C++11开始从语法层面支持了move语义，使用它可以使临时对象的拷贝具有move窃取功能
  * std::forward：将一组参数原封不动的传递给另一个函数，参数在传递过程中保持其值属性。完美转发可以使一个函数同时提供左值引用和右值引用的版本，在提高效率的同时简化代码

    ```C++
    template <typename T>
    void
    f(T&& rr) {
      if (std::is_reference<decltype(rr)>::value) {
        if (std::is_lvalue_reference<decltype(rr)>::value)
          std::cout << "lf" << std::endl;
        else if (std::is_rvalue_reference<decltype(rr)>::value)
          std::cout << "rf" << std::endl;
      } else {
        std::cout << "other" << std::endl;
      }
    }

    template <typename T>
    void
    ff(T&& rr) {
      f(std::forward<T>(rr));
    }

    int
    main(void) {
      int a = 1;
      int &ra = a;
      int *pa = &a;
      const int& r1 = 1;

      ff(std::move(a));
      ff(1);
      ff(ra);
      ff(pa);
      ff(r1);

      return 0;
    }
    
    //输出结果：
    //rf
    //rf
    //lf
    //lf
    //lf
    ```

## 异常
### 
  * 构造函数和析构函数可以抛出异常，但在析构函数中抛出异常容易导致内存泄漏
### 优点
### 缺点
### RAII
### 二段式构造

## 面向对象

### 类
  * 构造函数
  * 析构函数

### [分配器](https://zhuanlan.zhihu.com/p/185611161)

## 技巧
  * 可变长结构
  
    ```C
    struct {
      int iType;
      int iNum;
      int data[1];
    } DEMOMSG, *LPDEMOMSG;
    
    void
    pack_demo_msg (char *lpMsg, int data[], int iNum) {
      LPDEMOMSG lpDemoMsg = (LPDEMOMSG)lpMsg;
      lpDemoMsg->iNum = iNum;
      for (int i = 0; i < iNum; ++i) {
        lpDemoMsg.data[i] = data[i];
      }
    }
    ```

## 内存管理
  * new/delete与malloc/free：
    * new/delete是操作符。malloc/free是函数
    * new从自由存储区分配（默认为堆）。malloc从堆分配
    * new成功时返回对象指针，失败时抛出std::bad_alloc异常，使用new(std::nothrow)时返回NULL。malloc成功时返回内存起始指针，需要强制转换为具体类型的指针，失败时返回NULL
    * new根据对象的大小分配空间。malloc需要自行计算
    * new[]/delete[]对数组进行分配和释放，并且会对每个对象进行构造/析构
    * realloc可重新分配内存。而new没有相应功能，需要重载operator new()自行实现
    * C++可通过set_new_handler设置new的错误处理函数，在new抛出异常之前调用。malloc需要判断返回值并自行处理
    * new分配内存后会调用构造函数，delete释放内存前会调析构函数
  * 自由存储区和堆：
    * 自由存储区不等于堆，堆可以是自由存储区的子集
    * 自由存储区可以是任何内存空间，比如全局/静态的的对象池
  * malloc和calloc
    * calloc用于分配n块大小为size的连续空间
    * calloc对分配的整块内存置0，malloc不会，因此malloc效率更高
  * delete this注意：
    1. 确保对象是new出来的
    2. 确保delete后不会用该对象调用其它（非静态）成员函数
    3. 确保delete后不能访问对象的任何部分
    4. 确保delete后this指针不会被访问

# 操作系统

## 地址
  * 逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址（操作数）叫逻辑地址，由段地址和偏移地址组成
  * 物理地址：出现在CPU外部地址总线上的寻址物理内存的地址信号
  * 线性地址：段地址和逻辑地址组成线性地址，如果启用了分页机制，那么线性地址可以再经变换以产生一个物理地址，否则线性地址直接就是物理地址

## CPU寻址方式
  * 实模式：程序访问的地址都是真实的物理地址，如8086中“段基址：段内偏移地址”产生的逻辑地址就是物理地址。缺点：用户程序和操作系统拥有同等权利，程序可以随意修改任意物理地址，甚至包括操作系统所在的内存，给操作系统带来极大的安全问题
  * 保护模式：CPU访问的所有地址都是逻辑地址（段寄存器都为0的话，逻辑地址就是虚拟地址），CPU会通过“分段”或者“分页”方式来查寻到对应的物理地址。优点：不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持，支持多任务，能够快速地进行任务切换和保护任务环境

## [分页](https://www.zhihu.com/question/50796850)

## <a id="vms">虚拟地址空间</a>
  ![image](img/mem_space_cmp.jpg)
  以32位机器举例，进程的虚拟地址空间最大为4GB，其中1GB为内核空间（所有进程共享），进程可访问的实际用户空间只有3GB。
  Linux进程的内存段组成如下：
  * 保留区：0x00000000-0x08048000
  * 代码段（text）：线程间共享，只读
  * 数据段（data）：存放已初始化的且初始值不为0的全局变量和静态局部变量，可读写
  * BSS段：存放未初始化的静态变量、初始值为0的初始化的全局变量和静态变量、未定义且初值不为0的符号（该初值即common block的大小）。BSS段不占用可执行文件空间，推迟到加载阶段初始化为0（符号表中会有相关变量的描述）
  * 堆（heap）：堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减
  * 内存映射段（mmap）：mmap将文件映射到该段
  * 栈（stack）：由编译器自动分配释放，用于存放函数内的非静态局部变量、栈帧，可动态增长至RLIMIT_STACK
  * 环境变量和命令行参数
  * 其他
    * 只读数据段（rodata）：进程间共享，编译器自动去重。常量不一定在rodata，有可能在text
    * common段：存放未初始化的全局变量（有的编译器会直接放在BSS段）
      > 强符号和弱符号
      > * 强符号指函数和初始化的全局变量（包括初始值为0的），弱符号指未初始化的全局变量
      > * 同名的强符号只能有一个，否则链接器报"重复定义"错误
      > * 如果一个符号在某个目标文件中是强符号，在其他文件中是弱符号，那么选择强符号
      > * 如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个
      > * 应用：程序在未正常链接某个库时也可以正常运行、库中定义的弱符号可以被用户定义的强符号所覆盖（例如版本用户自定义）
      > 
      > 举例：
      > ```C
      > int a;                           # 弱符号
      > int b = 0;                       # 强符号
      > extern int c;                    # 外部符号，只是一个符号引用，即不是强符号也不是弱符号
      > int __attribute__((weak)) d = 2; # 弱符号
      > 
      > #if defined(_WIN32)
      >   #pragma weak e
      >   int e = 2;                     # 弱符号
      > #endif
      > 
      > int
      > main () {
      >   return 0;
      > }
      > ```

  ![image](img/Linux_mem_X86.jpg)
  ![image](img/Linux_mem_X64.jpg)
  
  目标文件各个段在文件中的布局：
  ![image](img/elf_and_proc.png)

  > [更多关于虚拟地址空间的内容](https://fanlv.wiki/2021/07/25/linux-mem/)

## mmap和shm
  * mmap（内存映射）：
    * 将一个文件或者其它对象映射到进程的虚拟地址空间，使用户对这段内存区域的修改可以直接反映到内核空间，相反，内核空间对这段区域的修改也直接反映用户空间
    * 读写文件时不再需要使用read、write等系统调用对文件进行读写，减少一次拷贝
    * 当访问该区域的内存页时，若该地址的数据不在内存，则产生缺页中断，OS会从磁盘中拷贝对应页到物理内存
    * 对该区域的内存页写入后，会自动延迟回写脏页面到对应磁盘地址，也可使用msync()即时写入
    * mmap 不仅可以映射到磁盘上的普通文件，还可以映射到匿名文件，但匿名映射只能在父子进程中使用
  * shm（共享内存）：
    * 将新开辟的物理内存映射到不同进程的虚拟地址空间
  * malloc分配大内存实际调用的是mmap
  * 区别：
    * mmap和shm都可以达到进程间通信和进共享的目的，但shm性能更高
    * mmap实际存储反应到硬盘，shm实际存储反应到内存
    * 对于普通文件的mmap映射，当机器重启，mmap文件还保存了同步映像

## 栈、堆
  * 栈：
    * [进程栈](#vms)
    * 线程栈
      * Linux内核没有线程的概念，Linux把线程当作进程来实现
      * Linux线程和进程的共享地址空间，但栈不共享，并且不能动态增长
      * Linux线程对应单个task，每个线程拥有一个task_struct，进程实际上是一个task组，每个进程拥有一个mm_struct，进程中的线程共享mm_struct结构
    * 内核栈
      * 进程通过到系统调用陷入内核时，使用的是单独的内核空间的栈，每个进程都会拥有属于自己的内核栈
    * 中断栈
      * 中断栈同样处于内核空间，中断栈是可以和内核栈共享，具体取决于内核的实现和处理架构
    > Linux的栈大小默认为8M（ulimit -s），可使用 `ulimit -s` 修改，Windows的栈大小默认为1M（VC6），可使用 `/stack` 参数修改
  * 堆：
    *
  * 栈和堆：
    * 生长方向：栈的地址增长方向取决于平台和编译器实现（比如x86的栈是向下增长的，原因是栈向下增长，堆向上增长，可以提高内存利用率）
    * 分配方式：栈由编译器自动分配和释放。堆由程序员控制，容易产生内存泄露
    * 空间大小：栈顶地址和栈的最大容量由系统预先规定，栈的大小超容量限制会栈溢出。堆的大小则受限于计算机系统中有效的地址空间
    * 效率：压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率较低
    * 碎片问题：栈是先进后出的队列，不存在碎片问题。堆的频繁申请释放操作会造成内存空间不连续，从而造成大量碎片，使程序效率降低

## 存储区域
  * 静态存储区：BSS段、数据段、代码段
  * 动态存储区：堆、栈

## 动态库、静态库

### 动态库
  *
### 静态库
  *
### **注意**
  1. **动态库中的全局变量、静态变量在进程间不会相互覆盖，写时拷贝（进程修改动态库中的全局变量、静态变量时，操作系统会重新分配内存并映射到进程地址空间，变量的逻辑地址不变）**
  2. **可执行文件和动态库同时引用同一个静态库，静态库中的全局变量和静态变量会分别初始化一次[详情](https://cloud.tencent.com/developer/article/1173666)**


# 编译原理

## PIC和PIE
  * PIC（位置无关代码）
  * PIE（位置无关可执行程序）
  * 两者是等价的，-fPIC用于生成动态库，-fPIE用与生成可执行文件

## _stdcall和__stdcall、_fastcall
  * __cdecl是C/C++和MFC程序默认使用的调用约定。函数参数按照从右到左的顺序入栈，并且由调用函数者把参数弹出栈以清理堆栈（可变参数只能用__cdecll；由于每个调用__cdecl函数的代码都要包含清理堆栈的代码，产生的可执行文件大小会比较大）
  * __stdcall调用约定用于调用Win32 API函数。函数参数按照从右到左的顺序入栈，被调用的函数在返回前清理传送参数的栈，函数参数个数固定
  * __fastcall约定用于对性能要求非常高的场合。_fastcall约定将函数的从左边开始的两个大小不大于4个字节（DWORD）的参数分别放在ECX和EDX寄存器，其余的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的堆栈。（__fastcall可以写成_fastcall）
  * thiscall仅仅应用于"C++"成员函数。this指针存放于CX寄存器，函数参数按照从右到左的顺序入栈，不能被程序员指定


# 汇编

## ESP、EBP
  * ESP（栈指针寄存器/栈指针）：永远指向系统栈栈顶
  * EBP（基址指针寄存器/帧指针）：永远指向系统栈栈底
  ![image](img/stack_frame.png)

# UNPV
  * [UNPV](https://github.com/ManyyWu/Notes/blob/master/Linux/Programming/UNP%E7%AC%94%E8%AE%B0.md)
  * [服务器IO模型](https://fanlv.wiki/2018/07/15/server-io-model/)


# Autotools


# make


# CMake

# [Shell](https://github.com/ManyyWu/Notes/blob/master/Linux/Programming/Shell.md)


# [MySQl](https://fanlv.wiki/categories/MySQL/)


# [Redis](https://fanlv.wiki/categories/Redis/)
